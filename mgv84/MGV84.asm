	list p=16f873
	#include <p16f873.inc>
	radix dec
; Begin
	R0L EQU 0x20
	R0H EQU 0x21
	R1L EQU 0x22
	R1H EQU 0x23
	R2L EQU 0x24
	R2H EQU 0x25
	R3L EQU 0x26
	R3H EQU 0x27
	R4L EQU 0x28
	R4H EQU 0x29
	R5L EQU 0x2A
	R5H EQU 0x2B
	SCL_PORT EQU 0x2C
	SCL_BIT EQU 0x2D
	SDA_PORT EQU 0x2E
	SDA_BIT EQU 0x2F
	ORG 0x0000
	BCF PCLATH,3
	BCF PCLATH,4
	GOTO L0011
	ORG 0x0004
	RETFIE
L0011:
; 1:  'program for control of 4 servomotors + 4 relais to switch turnout frogs.
; 2:  'new version also provides feed back of servomotor position after movement.
; 3:  'print MGV84
; 4:  'with jumper JP1 set, the program gets into adjust mode.
; 5:  'this enables adjust of:
; 6:  '-  change polarity to turnout frog
; 7:  '-  working angle of servo
; 8:  '-  speed of servo.
; 9: Dim motornumber As Byte
;       The address of 'motornumber' is 0x31
	motornumber EQU 0x31
; 10: Dim misc_value As Byte
;       The address of 'misc_value' is 0x32
	misc_value EQU 0x32
; 11: Dim dummy As Byte
;       The address of 'dummy' is 0x33
	dummy EQU 0x33
; 12: Dim dummy1 As Byte
;       The address of 'dummy1' is 0x34
	dummy1 EQU 0x34
; 13: Dim adjust As Bit
;       The address of 'adjust' is 0x30,0
; 14: Dim frog_left As Byte
;       The address of 'frog_left' is 0x35
	frog_left EQU 0x35
; 15: Dim frog_right As Byte
;       The address of 'frog_right' is 0x36
	frog_right EQU 0x36
; 16: Dim servo(5) As Byte
;       The address of 'servo' is 0x37
	servo EQU 0x37
; 17: Dim position(5) As Byte 'actual turnout position
;       The address of 'position' is 0x3C
	position EQU 0x3C
; 18: Dim position_asked(5) As Byte
;       The address of 'position_asked' is 0x41
	position_asked EQU 0x41
; 19: Dim angle_left(5) As Byte 'turning angle of servomotor
;       The address of 'angle_left' is 0x46
	angle_left EQU 0x46
; 20: Dim angle_right(5) As Byte
;       The address of 'angle_right' is 0x4B
	angle_right EQU 0x4B
; 21: Dim angle(5) As Byte
;       The address of 'angle' is 0x50
	angle EQU 0x50
; 22: Dim direction(5) As Byte 'this is position of the relay
;       The address of 'direction' is 0x55
	direction EQU 0x55
; 23: Dim speed(5) As Byte 'indicates speed of servomotor
;       The address of 'speed' is 0x5A
	speed EQU 0x5A
; 24: Dim expander_out As Byte
;       The address of 'expander_out' is 0x5F
	expander_out EQU 0x5F
; 25: Symbol servopower = PORTC.2
;       The address of 'servopower' is 0x7,2
; 26: ADCON1 = 0
	BSF STATUS,RP0
	CLRF 0x1F
; 27: TRISA = %111111 'set 6 PORTA pins as inputs and +/-Vref
	MOVLW 0x3F
	MOVWF 0x05
; 28: TRISB = %00000000 'set portb as output
	CLRF 0x06
; 29: PORTB = %11111111
	BCF STATUS,RP0
	MOVLW 0xFF
	MOVWF 0x06
; 30: TRISC = %00001011 'set portc.0,1,3 as input , rest is output
	BSF STATUS,RP0
	MOVLW 0x0B
	MOVWF 0x07
; 31: PORTC = %00001111
	BCF STATUS,RP0
	MOVLW 0x0F
	MOVWF 0x07
; 32: Symbol sda = PORTC.1 'I2c Initialisation
;       The address of 'sda' is 0x7,1
; 33: Symbol scl = PORTC.0 'I2c Initialisation
;       The address of 'scl' is 0x7,0
; 34: I2CPrepare sda, scl 'I2c Initialisation
	MOVLW 0x07
	MOVWF SDA_PORT
	MOVLW 0x02
	MOVWF SDA_BIT
	BSF STATUS,RP0
	BCF TRISC,1
	BCF STATUS,RP0
	MOVLW 0x07
	MOVWF SCL_PORT
	MOVLW 0x01
	MOVWF SCL_BIT
	BSF STATUS,RP0
	BCF TRISC,0
	BCF STATUS,RP0
	CALL IC41
	CALL IC41
; 35: Gosub read_eeprom 'read all settings
	CALL L0006
; 36: adjust = 0
	BCF 0x30,0
; 37: expander_out = 0
	CLRF 0x5F
; 38: For motornumber = 1 To 4
	MOVLW 0x01
	MOVWF 0x31
L0012:
	MOVF 0x31,W
	SUBLW 0x04
	BTFSS STATUS,C
	GOTO L0013
; 39: Gosub writeoutputs
	CALL L0010
; 40: If position(motornumber) = 0 Then
	MOVF 0x31,W
	ADDLW 0x3C
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0x00
	BTFSS STATUS,Z
	GOTO L0014
; 41: angle(motornumber) = angle_left(motornumber)
	MOVF 0x31,W
	ADDLW 0x46
	MOVWF FSR
	MOVF INDF,W
	MOVWF R5L
	MOVF 0x31,W
	ADDLW 0x50
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 42: Else
	GOTO L0015
L0014:	MOVLW 0x1F
	ANDWF STATUS,F
; 43: angle(motornumber) = angle_right(motornumber)
	MOVF 0x31,W
	ADDLW 0x4B
	MOVWF FSR
	MOVF INDF,W
	MOVWF R5L
	MOVF 0x31,W
	ADDLW 0x50
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 44: Endif
L0015:	MOVLW 0x1F
	ANDWF STATUS,F
; 45: Next motornumber
	MOVLW 0x01
	ADDWF 0x31,F
	BTFSS STATUS,C
	GOTO L0012
L0013:	MOVLW 0x1F
	ANDWF STATUS,F
; 46: For dummy = 1 To 20
	MOVLW 0x01
	MOVWF 0x33
L0016:
	MOVF 0x33,W
	SUBLW 0x14
	BTFSS STATUS,C
	GOTO L0017
; 47: ServoOut PORTC.4, angle(1)
	MOVF 0x51,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0019
	BSF PORTC,4
L0018:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0018
	BCF PORTC,4
L0019:
; 48: ServoOut PORTC.5, angle(2)
	MOVF 0x52,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0021
	BSF PORTC,5
L0020:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0020
	BCF PORTC,5
L0021:
; 49: ServoOut PORTC.6, angle(3)
	MOVF 0x53,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0023
	BSF PORTC,6
L0022:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0022
	BCF PORTC,6
L0023:
; 50: ServoOut PORTC.7, angle(4)
	MOVF 0x54,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0025
	BSF PORTC,7
L0024:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0024
	BCF PORTC,7
L0025:
; 51: If dummy = 5 Then
	MOVF 0x33,W
	SUBLW 0x05
	BTFSS STATUS,Z
	GOTO L0026
; 52: servopower = 0 'switch power to servo's
	BCF 0x07,2
; 53: Endif
L0026:	MOVLW 0x1F
	ANDWF STATUS,F
; 54: WaitMs 20
	MOVLW 0x14
	MOVWF R0L
	CLRF R0H
	CALL W001
; 55: Next dummy
	MOVLW 0x01
	ADDWF 0x33,F
	BTFSS STATUS,C
	GOTO L0016
L0017:	MOVLW 0x1F
	ANDWF STATUS,F
; 56: If PORTC.3 = 0 Then 'Adjustments activated
	BTFSC 0x07,3
	GOTO L0027
; 57: adjust = 1
	BSF 0x30,0
; 58: Goto adjustments
	GOTO L0005
; 59: Endif
L0027:	MOVLW 0x1F
	ANDWF STATUS,F
; 60: main: 
L0001:
; 61: Gosub getinputs 'get input commands
	CALL L0009
; 62: For motornumber = 1 To 4
	MOVLW 0x01
	MOVWF 0x31
L0028:
	MOVF 0x31,W
	SUBLW 0x04
	BTFSS STATUS,C
	GOTO L0029
; 63: frog_left = LookUp(0, %11111110, %11111011, %11101111, %10111111), motornumber
	MOVF 0x31,W
	SUBLW 0x04
	BTFSS STATUS,C
	GOTO L0030
	CALL L0031
	MOVWF 0x35
	GOTO L0030
L0031:
	MOVLW 0x01
	MOVWF PCLATH
	MOVF 0x31,W
	ADDWF PCL,F
	RETLW 0x00
	RETLW 0xFE
	RETLW 0xFB
	RETLW 0xEF
	RETLW 0xBF
L0030:
; 64: frog_right = LookUp(0, %11111101, %11110111, %11011111, %01111111), motornumber
	MOVF 0x31,W
	SUBLW 0x04
	BTFSS STATUS,C
	GOTO L0032
	CALL L0033
	MOVWF 0x36
	GOTO L0032
L0033:
	MOVLW 0x01
	MOVWF PCLATH
	MOVF 0x31,W
	ADDWF PCL,F
	RETLW 0x00
	RETLW 0xFD
	RETLW 0xF7
	RETLW 0xDF
	RETLW 0x7F
L0032:
; 65: If position_asked(motornumber) = 0 Then
	MOVF 0x31,W
	ADDLW 0x41
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0x00
	BTFSS STATUS,Z
	GOTO L0034
; 66: If position(motornumber) = 1 Then 'Turnout to be changed
	MOVF 0x31,W
	ADDLW 0x3C
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0x01
	BTFSS STATUS,Z
	GOTO L0035
; 67: Gosub servo_control_left
	CALL L0007
; 68: Endif
L0035:	MOVLW 0x1F
	ANDWF STATUS,F
; 69: Else
	GOTO L0036
L0034:	MOVLW 0x1F
	ANDWF STATUS,F
; 70: If position(motornumber) = 0 Then 'Turnout to be changed
	MOVF 0x31,W
	ADDLW 0x3C
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0x00
	BTFSS STATUS,Z
	GOTO L0037
; 71: Gosub servo_control_right
	CALL L0008
; 72: Endif
L0037:	MOVLW 0x1F
	ANDWF STATUS,F
; 73: Endif
L0036:	MOVLW 0x1F
	ANDWF STATUS,F
; 74: Next motornumber
	MOVLW 0x01
	ADDWF 0x31,F
	BTFSS STATUS,C
	GOTO L0028
L0029:	MOVLW 0x1F
	ANDWF STATUS,F
; 75: WaitMs 250
	MOVLW 0xFA
	MOVWF R0L
	CLRF R0H
	CALL W001
; 76: Goto main
	GOTO L0001
; 77: End
L0038:	GOTO L0038
; 78: 
; 79: measure_relay_postion: 
L0002:
; 80: If PORTC.3 = 0 Then
	BTFSC 0x07,3
	GOTO L0039
; 81: direction(motornumber) = 0
	MOVF 0x31,W
	ADDLW 0x55
	MOVWF FSR
	MOVLW 0x00
	MOVWF INDF
; 82: Else
	GOTO L0040
L0039:	MOVLW 0x1F
	ANDWF STATUS,F
; 83: direction(motornumber) = 1
	MOVF 0x31,W
	ADDLW 0x55
	MOVWF FSR
	MOVLW 0x01
	MOVWF INDF
; 84: Endif
L0040:	MOVLW 0x1F
	ANDWF STATUS,F
; 85: dummy = 12 + motornumber 'adress in EEprom
	MOVLW 0x0C
	ADDWF 0x31,W
	MOVWF 0x33
; 86: Write dummy, direction(motornumber)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BCF STATUS,RP1
	MOVF 0x31,W
	ADDLW 0x55
	MOVWF FSR
	MOVF INDF,W
	BSF STATUS,RP1
	MOVWF EEDATA
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,WREN
	MOVLW 0x55
	MOVWF EECON2
	MOVLW 0xAA
	MOVWF EECON2
	BSF EECON1,WR
L0041:	BTFSC EECON1,WR
	GOTO L0041
	BCF EECON1,WREN
	BCF STATUS,RP1
	BCF STATUS,RP0
	BCF PIR2,EEIF
; 87: Return
	RETURN
; 88: 
; 89: measure_speed: 
L0003:
; 90: Adcin 0, misc_value
	BSF STATUS,RP0
	BCF ADCON1,ADFM
	MOVLW 0x00
	BCF STATUS,RP0
	MOVWF R0L
	CALL A001
	MOVF ADRESH,W
	MOVWF 0x32
; 91: If misc_value = 0 Then 'zero not allowed
	MOVF 0x32,W
	SUBLW 0x00
	BTFSS STATUS,Z
	GOTO L0042
; 92: misc_value = 1
	MOVLW 0x01
	MOVWF 0x32
; 93: Endif
L0042:	MOVLW 0x1F
	ANDWF STATUS,F
; 94: speed(motornumber) = misc_value
	MOVF 0x32,W
	MOVWF R5L
	MOVF 0x31,W
	ADDLW 0x5A
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 95: dummy = 16 + motornumber 'adress in EEprom
	MOVLW 0x10
	ADDWF 0x31,W
	MOVWF 0x33
; 96: Write dummy, speed(motornumber)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BCF STATUS,RP1
	MOVF 0x31,W
	ADDLW 0x5A
	MOVWF FSR
	MOVF INDF,W
	BSF STATUS,RP1
	MOVWF EEDATA
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,WREN
	MOVLW 0x55
	MOVWF EECON2
	MOVLW 0xAA
	MOVWF EECON2
	BSF EECON1,WR
L0043:	BTFSC EECON1,WR
	GOTO L0043
	BCF EECON1,WREN
	BCF STATUS,RP1
	BCF STATUS,RP0
	BCF PIR2,EEIF
; 97: Return
	RETURN
; 98: 
; 99: measure_angle: 
L0004:
; 100: Adcin 1, misc_value
	BSF STATUS,RP0
	BCF ADCON1,ADFM
	MOVLW 0x01
	BCF STATUS,RP0
	MOVWF R0L
	CALL A001
	MOVF ADRESH,W
	MOVWF 0x32
; 101: If misc_value < 8 Then
	MOVLW 0x08
	SUBWF 0x32,W
	BTFSC STATUS,C
	GOTO L0044
; 102: misc_value = 8
	MOVLW 0x08
	MOVWF 0x32
; 103: Endif
L0044:	MOVLW 0x1F
	ANDWF STATUS,F
; 104: misc_value = misc_value / 2
	MOVF 0x32,W
	MOVWF R0L
	CLRF R0H
	MOVLW 0x02
	MOVWF R1L
	CLRF R1H
	CALL D001
	MOVWF 0x32
; 105: angle_left(motornumber) = 128 - misc_value
	MOVF 0x32,W
	SUBLW 0x80
	MOVWF R5L
	MOVF 0x31,W
	ADDLW 0x46
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 106: If angle_left(motornumber) < 55 Then
	MOVLW 0x37
	MOVWF R5L
	MOVF 0x31,W
	ADDLW 0x46
	MOVWF FSR
	MOVF R5L,W
	SUBWF INDF,W
	BTFSC STATUS,C
	GOTO L0045
; 107: angle_left(motornumber) = 55
	MOVF 0x31,W
	ADDLW 0x46
	MOVWF FSR
	MOVLW 0x37
	MOVWF INDF
; 108: Endif
L0045:	MOVLW 0x1F
	ANDWF STATUS,F
; 109: angle_right(motornumber) = 127 + misc_value
	MOVLW 0x7F
	ADDWF 0x32,W
	MOVWF R5L
	MOVF 0x31,W
	ADDLW 0x4B
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 110: If angle_right(motornumber) > 245 Then
	MOVF 0x31,W
	ADDLW 0x4B
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0xF5
	BTFSC STATUS,C
	GOTO L0046
; 111: angle_right(motornumber) = 245
	MOVF 0x31,W
	ADDLW 0x4B
	MOVWF FSR
	MOVLW 0xF5
	MOVWF INDF
; 112: Endif
L0046:	MOVLW 0x1F
	ANDWF STATUS,F
; 113: dummy = motornumber + 4 'adress in EEprom
	MOVF 0x31,W
	ADDLW 0x04
	MOVWF 0x33
; 114: Write dummy, angle_left(motornumber)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BCF STATUS,RP1
	MOVF 0x31,W
	ADDLW 0x46
	MOVWF FSR
	MOVF INDF,W
	BSF STATUS,RP1
	MOVWF EEDATA
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,WREN
	MOVLW 0x55
	MOVWF EECON2
	MOVLW 0xAA
	MOVWF EECON2
	BSF EECON1,WR
L0047:	BTFSC EECON1,WR
	GOTO L0047
	BCF EECON1,WREN
	BCF STATUS,RP1
	BCF STATUS,RP0
	BCF PIR2,EEIF
; 115: dummy = dummy + 4 'adress in EEprom
	MOVF 0x33,W
	ADDLW 0x04
	MOVWF 0x33
; 116: Write dummy, angle_right(motornumber)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BCF STATUS,RP1
	MOVF 0x31,W
	ADDLW 0x4B
	MOVWF FSR
	MOVF INDF,W
	BSF STATUS,RP1
	MOVWF EEDATA
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,WREN
	MOVLW 0x55
	MOVWF EECON2
	MOVLW 0xAA
	MOVWF EECON2
	BSF EECON1,WR
L0048:	BTFSC EECON1,WR
	GOTO L0048
	BCF EECON1,WREN
	BCF STATUS,RP1
	BCF STATUS,RP0
	BCF PIR2,EEIF
; 117: Return
	RETURN
; 118: 
; 119: adjustments: 
L0005:
; 120: Gosub getinputs
	CALL L0009
; 121: For motornumber = 1 To 4
	MOVLW 0x01
	MOVWF 0x31
L0049:
	MOVF 0x31,W
	SUBLW 0x04
	BTFSS STATUS,C
	GOTO L0050
; 122: If position_asked(motornumber) = 0 Then
	MOVF 0x31,W
	ADDLW 0x41
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0x00
	BTFSS STATUS,Z
	GOTO L0051
; 123: frog_left = LookUp(0, %11111110, %11111011, %11101111, %10111111), motornumber
	MOVF 0x31,W
	SUBLW 0x04
	BTFSS STATUS,C
	GOTO L0052
	CALL L0053
	MOVWF 0x35
	GOTO L0052
L0053:
	MOVLW 0x02
	MOVWF PCLATH
	MOVF 0x31,W
	ADDWF PCL,F
	RETLW 0x00
	RETLW 0xFE
	RETLW 0xFB
	RETLW 0xEF
	RETLW 0xBF
L0052:
; 124: frog_right = LookUp(0, %11111101, %11110111, %11011111, %01111111), motornumber
	MOVF 0x31,W
	SUBLW 0x04
	BTFSS STATUS,C
	GOTO L0054
	CALL L0055
	MOVWF 0x36
	GOTO L0054
L0055:
	MOVLW 0x02
	MOVWF PCLATH
	MOVF 0x31,W
	ADDWF PCL,F
	RETLW 0x00
	RETLW 0xFD
	RETLW 0xF7
	RETLW 0xDF
	RETLW 0x7F
L0054:
; 125: Gosub measure_relay_postion
	CALL L0002
; 126: Gosub measure_speed
	CALL L0003
; 127: Gosub measure_angle
	CALL L0004
; 128: Gosub servo_control_left
	CALL L0007
; 129: WaitMs 1000
	MOVLW 0xE8
	MOVWF R0L
	MOVLW 0x03
	MOVWF R0H
	CALL W001
; 130: Gosub servo_control_right
	CALL L0008
; 131: WaitMs 1000
	MOVLW 0xE8
	MOVWF R0L
	MOVLW 0x03
	MOVWF R0H
	CALL W001
; 132: Endif
L0051:	MOVLW 0x1F
	ANDWF STATUS,F
; 133: Next motornumber
	MOVLW 0x01
	ADDWF 0x31,F
	BTFSS STATUS,C
	GOTO L0049
L0050:	MOVLW 0x1F
	ANDWF STATUS,F
; 134: Goto adjustments
	GOTO L0005
; 135: 
; 136: read_eeprom: 
L0006:
; 137: For dummy = 1 To 4
	MOVLW 0x01
	MOVWF 0x33
L0056:
	MOVF 0x33,W
	SUBLW 0x04
	BTFSS STATUS,C
	GOTO L0057
; 138: Read dummy, position(dummy)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,RD
	NOP
	BCF STATUS,RP0
	MOVF EEDATA,W
	BCF STATUS,RP1
	MOVWF R5L
	MOVF 0x33,W
	ADDLW 0x3C
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 139: If position(dummy) = 255 Then
	MOVF 0x33,W
	ADDLW 0x3C
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0xFF
	BTFSS STATUS,Z
	GOTO L0058
; 140: position(dummy) = 0
	MOVF 0x33,W
	ADDLW 0x3C
	MOVWF FSR
	MOVLW 0x00
	MOVWF INDF
; 141: Endif
L0058:	MOVLW 0x1F
	ANDWF STATUS,F
; 142: Next dummy
	MOVLW 0x01
	ADDWF 0x33,F
	BTFSS STATUS,C
	GOTO L0056
L0057:	MOVLW 0x1F
	ANDWF STATUS,F
; 143: For dummy = 5 To 8
	MOVLW 0x05
	MOVWF 0x33
L0059:
	MOVF 0x33,W
	SUBLW 0x08
	BTFSS STATUS,C
	GOTO L0060
; 144: misc_value = dummy - 4
	MOVLW 0x04
	SUBWF 0x33,W
	MOVWF 0x32
; 145: Read dummy, angle_left(misc_value)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,RD
	NOP
	BCF STATUS,RP0
	MOVF EEDATA,W
	BCF STATUS,RP1
	MOVWF R5L
	MOVF 0x32,W
	ADDLW 0x46
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 146: If angle_left(misc_value) = 255 Then
	MOVF 0x32,W
	ADDLW 0x46
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0xFF
	BTFSS STATUS,Z
	GOTO L0061
; 147: angle_left(misc_value) = 60
	MOVF 0x32,W
	ADDLW 0x46
	MOVWF FSR
	MOVLW 0x3C
	MOVWF INDF
; 148: Endif
L0061:	MOVLW 0x1F
	ANDWF STATUS,F
; 149: Next dummy
	MOVLW 0x01
	ADDWF 0x33,F
	BTFSS STATUS,C
	GOTO L0059
L0060:	MOVLW 0x1F
	ANDWF STATUS,F
; 150: For dummy = 9 To 12
	MOVLW 0x09
	MOVWF 0x33
L0062:
	MOVF 0x33,W
	SUBLW 0x0C
	BTFSS STATUS,C
	GOTO L0063
; 151: misc_value = dummy - 8
	MOVLW 0x08
	SUBWF 0x33,W
	MOVWF 0x32
; 152: Read dummy, angle_right(misc_value)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,RD
	NOP
	BCF STATUS,RP0
	MOVF EEDATA,W
	BCF STATUS,RP1
	MOVWF R5L
	MOVF 0x32,W
	ADDLW 0x4B
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 153: If angle_right(misc_value) = 255 Then
	MOVF 0x32,W
	ADDLW 0x4B
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0xFF
	BTFSS STATUS,Z
	GOTO L0064
; 154: angle_right(misc_value) = 200
	MOVF 0x32,W
	ADDLW 0x4B
	MOVWF FSR
	MOVLW 0xC8
	MOVWF INDF
; 155: Endif
L0064:	MOVLW 0x1F
	ANDWF STATUS,F
; 156: Next dummy
	MOVLW 0x01
	ADDWF 0x33,F
	BTFSS STATUS,C
	GOTO L0062
L0063:	MOVLW 0x1F
	ANDWF STATUS,F
; 157: For dummy = 13 To 16
	MOVLW 0x0D
	MOVWF 0x33
L0065:
	MOVF 0x33,W
	SUBLW 0x10
	BTFSS STATUS,C
	GOTO L0066
; 158: misc_value = dummy - 12
	MOVLW 0x0C
	SUBWF 0x33,W
	MOVWF 0x32
; 159: Read dummy, direction(misc_value)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,RD
	NOP
	BCF STATUS,RP0
	MOVF EEDATA,W
	BCF STATUS,RP1
	MOVWF R5L
	MOVF 0x32,W
	ADDLW 0x55
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 160: If direction(misc_value) = 255 Then
	MOVF 0x32,W
	ADDLW 0x55
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0xFF
	BTFSS STATUS,Z
	GOTO L0067
; 161: direction(misc_value) = 0
	MOVF 0x32,W
	ADDLW 0x55
	MOVWF FSR
	MOVLW 0x00
	MOVWF INDF
; 162: Endif
L0067:	MOVLW 0x1F
	ANDWF STATUS,F
; 163: Next dummy
	MOVLW 0x01
	ADDWF 0x33,F
	BTFSS STATUS,C
	GOTO L0065
L0066:	MOVLW 0x1F
	ANDWF STATUS,F
; 164: For dummy = 17 To 20
	MOVLW 0x11
	MOVWF 0x33
L0068:
	MOVF 0x33,W
	SUBLW 0x14
	BTFSS STATUS,C
	GOTO L0069
; 165: misc_value = dummy - 16
	MOVLW 0x10
	SUBWF 0x33,W
	MOVWF 0x32
; 166: Read dummy, speed(misc_value)
	MOVF 0x33,W
	BSF STATUS,RP1
	MOVWF EEADR
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,RD
	NOP
	BCF STATUS,RP0
	MOVF EEDATA,W
	BCF STATUS,RP1
	MOVWF R5L
	MOVF 0x32,W
	ADDLW 0x5A
	MOVWF FSR
	MOVF R5L,W
	MOVWF INDF
; 167: If speed(misc_value) = 255 Then
	MOVF 0x32,W
	ADDLW 0x5A
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0xFF
	BTFSS STATUS,Z
	GOTO L0070
; 168: speed(misc_value) = 20
	MOVF 0x32,W
	ADDLW 0x5A
	MOVWF FSR
	MOVLW 0x14
	MOVWF INDF
; 169: Endif
L0070:	MOVLW 0x1F
	ANDWF STATUS,F
; 170: Next dummy
	MOVLW 0x01
	ADDWF 0x33,F
	BTFSS STATUS,C
	GOTO L0068
L0069:	MOVLW 0x1F
	ANDWF STATUS,F
; 171: Return
	RETURN
; 172: 
; 173: servo_control_left: 
L0007:
; 174: misc_value = angle_right(motornumber) - 1
	MOVLW 0x01
	MOVWF R5L
	MOVF 0x31,W
	ADDLW 0x4B
	MOVWF FSR
	MOVF R5L,W
	SUBWF INDF,W
	MOVWF 0x32
; 175: While misc_value > angle_left(motornumber)
L0071:
	MOVF 0x32,W
	MOVWF R5L
	MOVF 0x31,W
	ADDLW 0x46
	MOVWF FSR
	MOVF R5L,W
	SUBWF INDF,W
	BTFSC STATUS,C
	GOTO L0072
; 176: If misc_value = 128 Then 'change frog polarity in middle position
	MOVF 0x32,W
	SUBLW 0x80
	BTFSS STATUS,Z
	GOTO L0073
; 177: If direction(motornumber) = 1 Then
	MOVF 0x31,W
	ADDLW 0x55
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0x01
	BTFSS STATUS,Z
	GOTO L0074
; 178: PORTB = frog_left
	MOVF 0x35,W
	MOVWF 0x06
; 179: Else
	GOTO L0075
L0074:	MOVLW 0x1F
	ANDWF STATUS,F
; 180: PORTB = frog_right
	MOVF 0x36,W
	MOVWF 0x06
; 181: Endif
L0075:	MOVLW 0x1F
	ANDWF STATUS,F
; 182: Endif
L0073:	MOVLW 0x1F
	ANDWF STATUS,F
; 183: Select Case motornumber
; 184: Case 1
	MOVF 0x31,W
	SUBLW 0x01
	BTFSS STATUS,Z
	GOTO L0076
; 185: ServoOut PORTC.4, misc_value
	MOVF 0x32,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0078
	BSF PORTC,4
L0077:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0077
	BCF PORTC,4
L0078:
; 186: Case 2
	GOTO L0079
L0076:	MOVLW 0x1F
	ANDWF STATUS,F
	MOVF 0x31,W
	SUBLW 0x02
	BTFSS STATUS,Z
	GOTO L0080
; 187: ServoOut PORTC.5, misc_value
	MOVF 0x32,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0082
	BSF PORTC,5
L0081:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0081
	BCF PORTC,5
L0082:
; 188: Case 3
	GOTO L0083
L0080:	MOVLW 0x1F
	ANDWF STATUS,F
	MOVF 0x31,W
	SUBLW 0x03
	BTFSS STATUS,Z
	GOTO L0084
; 189: ServoOut PORTC.6, misc_value
	MOVF 0x32,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0086
	BSF PORTC,6
L0085:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0085
	BCF PORTC,6
L0086:
; 190: Case Else
	GOTO L0087
L0084:	MOVLW 0x1F
	ANDWF STATUS,F
; 191: ServoOut PORTC.7, misc_value
	MOVF 0x32,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0089
	BSF PORTC,7
L0088:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0088
	BCF PORTC,7
L0089:
; 192: EndSelect
L0087:	MOVLW 0x1F
	ANDWF STATUS,F
L0083:	MOVLW 0x1F
	ANDWF STATUS,F
L0079:	MOVLW 0x1F
	ANDWF STATUS,F
; 193: WaitMs speed(motornumber)
	MOVF 0x31,W
	ADDLW 0x5A
	MOVWF FSR
	MOVF INDF,W
	MOVWF R0L
	CLRF R0H
	CALL W001
; 194: misc_value = misc_value - 1
	MOVLW 0x01
	SUBWF 0x32,W
	MOVWF 0x32
; 195: Wend
	GOTO L0071
L0072:	MOVLW 0x1F
	ANDWF STATUS,F
; 196: PORTB = %11111111
	MOVLW 0xFF
	MOVWF 0x06
; 197: position(motornumber) = 0
	MOVF 0x31,W
	ADDLW 0x3C
	MOVWF FSR
	MOVLW 0x00
	MOVWF INDF
; 198: Gosub writeoutputs
	CALL L0010
; 199: Write motornumber, 0 'Position saved
	MOVF 0x31,W
	BSF STATUS,RP1
	MOVWF EEADR
	MOVLW 0x00
	MOVWF EEDATA
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,WREN
	MOVLW 0x55
	MOVWF EECON2
	MOVLW 0xAA
	MOVWF EECON2
	BSF EECON1,WR
L0090:	BTFSC EECON1,WR
	GOTO L0090
	BCF EECON1,WREN
	BCF STATUS,RP1
	BCF STATUS,RP0
	BCF PIR2,EEIF
; 200: Return
	RETURN
; 201: servo_control_right: 
L0008:
; 202: misc_value = angle_left(motornumber) + 1
	MOVF 0x31,W
	ADDLW 0x46
	MOVWF FSR
	MOVF INDF,W
	ADDLW 0x01
	MOVWF 0x32
; 203: While misc_value < angle_right(motornumber)
L0091:
	MOVF 0x31,W
	ADDLW 0x4B
	MOVWF FSR
	MOVF INDF,W
	SUBWF 0x32,W
	BTFSC STATUS,C
	GOTO L0092
; 204: If misc_value = 128 Then 'change frog polarity in middle position
	MOVF 0x32,W
	SUBLW 0x80
	BTFSS STATUS,Z
	GOTO L0093
; 205: If direction(motornumber) = 1 Then
	MOVF 0x31,W
	ADDLW 0x55
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0x01
	BTFSS STATUS,Z
	GOTO L0094
; 206: PORTB = frog_right
	MOVF 0x36,W
	MOVWF 0x06
; 207: Else
	GOTO L0095
L0094:	MOVLW 0x1F
	ANDWF STATUS,F
; 208: PORTB = frog_left
	MOVF 0x35,W
	MOVWF 0x06
; 209: Endif
L0095:	MOVLW 0x1F
	ANDWF STATUS,F
; 210: Endif
L0093:	MOVLW 0x1F
	ANDWF STATUS,F
; 211: Select Case motornumber
; 212: Case 1
	MOVF 0x31,W
	SUBLW 0x01
	BTFSS STATUS,Z
	GOTO L0096
; 213: ServoOut PORTC.4, misc_value
	MOVF 0x32,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0098
	BSF PORTC,4
L0097:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0097
	BCF PORTC,4
L0098:
; 214: Case 2
	GOTO L0099
L0096:	MOVLW 0x1F
	ANDWF STATUS,F
	MOVF 0x31,W
	SUBLW 0x02
	BTFSS STATUS,Z
	GOTO L0100
; 215: ServoOut PORTC.5, misc_value
	MOVF 0x32,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0102
	BSF PORTC,5
L0101:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0101
	BCF PORTC,5
L0102:
; 216: Case 3
	GOTO L0103
L0100:	MOVLW 0x1F
	ANDWF STATUS,F
	MOVF 0x31,W
	SUBLW 0x03
	BTFSS STATUS,Z
	GOTO L0104
; 217: ServoOut PORTC.6, misc_value
	MOVF 0x32,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0106
	BSF PORTC,6
L0105:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0105
	BCF PORTC,6
L0106:
; 218: Case Else
	GOTO L0107
L0104:	MOVLW 0x1F
	ANDWF STATUS,F
; 219: ServoOut PORTC.7, misc_value
	MOVF 0x32,W
	MOVWF R4H
	MOVF R4H,F
	BTFSC STATUS,Z
	GOTO L0109
	BSF PORTC,7
L0108:
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	DECF R4H,F
	BTFSS STATUS,Z
	GOTO L0108
	BCF PORTC,7
L0109:
; 220: EndSelect
L0107:	MOVLW 0x1F
	ANDWF STATUS,F
L0103:	MOVLW 0x1F
	ANDWF STATUS,F
L0099:	MOVLW 0x1F
	ANDWF STATUS,F
; 221: WaitMs speed(motornumber)
	MOVF 0x31,W
	ADDLW 0x5A
	MOVWF FSR
	MOVF INDF,W
	MOVWF R0L
	CLRF R0H
	CALL W001
; 222: misc_value = misc_value + 1
	MOVF 0x32,W
	ADDLW 0x01
	MOVWF 0x32
; 223: Wend
	GOTO L0091
L0092:	MOVLW 0x1F
	ANDWF STATUS,F
; 224: PORTB = %11111111
	MOVLW 0xFF
	MOVWF 0x06
; 225: position(motornumber) = 1
	MOVF 0x31,W
	ADDLW 0x3C
	MOVWF FSR
	MOVLW 0x01
	MOVWF INDF
; 226: Gosub writeoutputs
	CALL L0010
; 227: Write motornumber, 1 'Position saved
	MOVF 0x31,W
	BSF STATUS,RP1
	MOVWF EEADR
	MOVLW 0x01
	MOVWF EEDATA
	BSF STATUS,RP0
	BCF EECON1,EEPGD
	BSF EECON1,WREN
	MOVLW 0x55
	MOVWF EECON2
	MOVLW 0xAA
	MOVWF EECON2
	BSF EECON1,WR
L0110:	BTFSC EECON1,WR
	GOTO L0110
	BCF EECON1,WREN
	BCF STATUS,RP1
	BCF STATUS,RP0
	BCF PIR2,EEIF
; 228: Return
	RETURN
; 229: getinputs: 
L0009:
; 230: I2CStart 'Issue I2C start signal
	CALL IC31
; 231: I2CSend 65 'Send adress for U4
	MOVLW 0x41
	CALL IC01
; 232: I2CRecN dummy 'Read the input commands
	CALL IC11
	MOVWF 0x33
; 233: I2CStop 'Issue
	CALL IC41
; 234: dummy1 = dummy
	MOVF 0x33,W
	MOVWF 0x34
; 235: dummy1 = dummy1 And 128
	MOVF 0x34,W
	MOVWF R0L
	MOVLW 0x80
	ANDWF R0L,W
	MOVWF 0x34
; 236: If dummy1 > 0 Then
	MOVF 0x34,W
	SUBLW 0x00
	BTFSC STATUS,C
	GOTO L0111
; 237: position_asked(1) = 1
	MOVLW 0x01
	MOVWF 0x42
; 238: Else
	GOTO L0112
L0111:	MOVLW 0x1F
	ANDWF STATUS,F
; 239: position_asked(1) = 0
	CLRF 0x42
; 240: Endif
L0112:	MOVLW 0x1F
	ANDWF STATUS,F
; 241: dummy1 = dummy
	MOVF 0x33,W
	MOVWF 0x34
; 242: dummy1 = dummy1 And 64
	MOVF 0x34,W
	MOVWF R0L
	MOVLW 0x40
	ANDWF R0L,W
	MOVWF 0x34
; 243: If dummy1 > 0 Then
	MOVF 0x34,W
	SUBLW 0x00
	BTFSC STATUS,C
	GOTO L0113
; 244: position_asked(2) = 1
	MOVLW 0x01
	MOVWF 0x43
; 245: Else
	GOTO L0114
L0113:	MOVLW 0x1F
	ANDWF STATUS,F
; 246: position_asked(2) = 0
	CLRF 0x43
; 247: Endif
L0114:	MOVLW 0x1F
	ANDWF STATUS,F
; 248: dummy1 = dummy
	MOVF 0x33,W
	MOVWF 0x34
; 249: dummy1 = dummy1 And 32
	MOVF 0x34,W
	MOVWF R0L
	MOVLW 0x20
	ANDWF R0L,W
	MOVWF 0x34
; 250: If dummy1 > 0 Then
	MOVF 0x34,W
	SUBLW 0x00
	BTFSC STATUS,C
	GOTO L0115
; 251: position_asked(3) = 1
	MOVLW 0x01
	MOVWF 0x44
; 252: Else
	GOTO L0116
L0115:	MOVLW 0x1F
	ANDWF STATUS,F
; 253: position_asked(3) = 0
	CLRF 0x44
; 254: Endif
L0116:	MOVLW 0x1F
	ANDWF STATUS,F
; 255: dummy1 = dummy
	MOVF 0x33,W
	MOVWF 0x34
; 256: dummy1 = dummy1 And 16
	MOVF 0x34,W
	MOVWF R0L
	MOVLW 0x10
	ANDWF R0L,W
	MOVWF 0x34
; 257: If dummy1 > 0 Then
	MOVF 0x34,W
	SUBLW 0x00
	BTFSC STATUS,C
	GOTO L0117
; 258: position_asked(4) = 1
	MOVLW 0x01
	MOVWF 0x45
; 259: Else
	GOTO L0118
L0117:	MOVLW 0x1F
	ANDWF STATUS,F
; 260: position_asked(4) = 0
	CLRF 0x45
; 261: Endif
L0118:	MOVLW 0x1F
	ANDWF STATUS,F
; 262: 
; 263: Return
	RETURN
; 264: writeoutputs: 
L0010:
; 265: If position(motornumber) = 1 Then
	MOVF 0x31,W
	ADDLW 0x3C
	MOVWF FSR
	MOVF INDF,W
	SUBLW 0x01
	BTFSS STATUS,Z
	GOTO L0119
; 266: Select Case motornumber
; 267: Case 1
	MOVF 0x31,W
	SUBLW 0x01
	BTFSS STATUS,Z
	GOTO L0120
; 268: expander_out = expander_out Or 8
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0x08
	IORWF R0L,W
	MOVWF 0x5F
; 269: Case 2
	GOTO L0121
L0120:	MOVLW 0x1F
	ANDWF STATUS,F
	MOVF 0x31,W
	SUBLW 0x02
	BTFSS STATUS,Z
	GOTO L0122
; 270: expander_out = expander_out Or 4
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0x04
	IORWF R0L,W
	MOVWF 0x5F
; 271: Case 3
	GOTO L0123
L0122:	MOVLW 0x1F
	ANDWF STATUS,F
	MOVF 0x31,W
	SUBLW 0x03
	BTFSS STATUS,Z
	GOTO L0124
; 272: expander_out = expander_out Or 2
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0x02
	IORWF R0L,W
	MOVWF 0x5F
; 273: Case Else
	GOTO L0125
L0124:	MOVLW 0x1F
	ANDWF STATUS,F
; 274: expander_out = expander_out Or 1
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0x01
	IORWF R0L,W
	MOVWF 0x5F
; 275: EndSelect
L0125:	MOVLW 0x1F
	ANDWF STATUS,F
L0123:	MOVLW 0x1F
	ANDWF STATUS,F
L0121:	MOVLW 0x1F
	ANDWF STATUS,F
; 276: Else
	GOTO L0126
L0119:	MOVLW 0x1F
	ANDWF STATUS,F
; 277: Select Case motornumber
; 278: Case 1
	MOVF 0x31,W
	SUBLW 0x01
	BTFSS STATUS,Z
	GOTO L0127
; 279: expander_out = expander_out And 7
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0x07
	ANDWF R0L,W
	MOVWF 0x5F
; 280: Case 2
	GOTO L0128
L0127:	MOVLW 0x1F
	ANDWF STATUS,F
	MOVF 0x31,W
	SUBLW 0x02
	BTFSS STATUS,Z
	GOTO L0129
; 281: expander_out = expander_out And 11
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0x0B
	ANDWF R0L,W
	MOVWF 0x5F
; 282: Case 3
	GOTO L0130
L0129:	MOVLW 0x1F
	ANDWF STATUS,F
	MOVF 0x31,W
	SUBLW 0x03
	BTFSS STATUS,Z
	GOTO L0131
; 283: expander_out = expander_out And 13
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0x0D
	ANDWF R0L,W
	MOVWF 0x5F
; 284: Case Else
	GOTO L0132
L0131:	MOVLW 0x1F
	ANDWF STATUS,F
; 285: expander_out = expander_out And 14
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0x0E
	ANDWF R0L,W
	MOVWF 0x5F
; 286: EndSelect
L0132:	MOVLW 0x1F
	ANDWF STATUS,F
L0130:	MOVLW 0x1F
	ANDWF STATUS,F
L0128:	MOVLW 0x1F
	ANDWF STATUS,F
; 287: Endif
L0126:	MOVLW 0x1F
	ANDWF STATUS,F
; 288: expander_out = expander_out Or 240 'leave high nibble as input
	MOVF 0x5F,W
	MOVWF R0L
	MOVLW 0xF0
	IORWF R0L,W
	MOVWF 0x5F
; 289: I2CStart 'Issue I2C start signal
	CALL IC31
; 290: I2CSend 64 'send adress u4
	MOVLW 0x40
	CALL IC01
; 291: I2CSend expander_out 'Send data to U4
	MOVF 0x5F,W
	CALL IC01
; 292: I2CStop 'Issue stop
	CALL IC41
; 293: 
; 294: Return
	RETURN
; End of program
L0133:	GOTO L0133
; Division Routine
D001:	MOVLW 0x10
	MOVWF R3L
	CLRF R2H
	CLRF R2L
D002:	RLF R0H,W
	RLF R2L,F
	RLF R2H,F
	MOVF R1L,W
	SUBWF R2L,F
	MOVF R1H,W
	BTFSS STATUS,C
	INCFSZ R1H,W
	SUBWF R2H,F
	BTFSC STATUS,C
	GOTO D003
	MOVF R1L,W
	ADDWF R2L,F
	MOVF R1H,W
	BTFSC STATUS,C
	INCFSZ R1H,W
	ADDWF R2H,F
	BCF STATUS,C
D003:	RLF R0L,F
	RLF R0H,F
	DECFSZ R3L,F
	GOTO D002
	MOVF R0L,W
	RETURN
; Waitms Routine
W001:	MOVF R0L,F
	BTFSC STATUS,Z
	GOTO W002
	CALL W003
	DECF R0L,F
	NOP
	NOP
	NOP
	NOP
	NOP
	GOTO W001
W002:	MOVF R0H,F
	BTFSC STATUS,Z
	RETURN
	CALL W003
	DECF R0H,F
	DECF R0L,F
	GOTO W001
W003:	MOVLW 0x0C
	MOVWF R2H
W004:	DECFSZ R2H,F
	GOTO W004
	NOP
	NOP
	MOVLW 0x62
	MOVWF R1L
W005:	DECFSZ R1L,F
	GOTO W006
	CALL W007
	CALL W007
	NOP
	NOP
	RETURN
W006:	CALL W007
	GOTO W005
W007:	MOVLW 0x0D
	MOVWF R2L
W008:	DECFSZ R2L,F
	GOTO W008
	NOP
	RETURN
; Waitus Routine - Byte Argument
X001:	MOVLW 0x02
	SUBWF R4L,F
	BTFSS STATUS,C
	RETURN
	GOTO X002
X002:	MOVLW 0x02
	SUBWF R4L,F
	NOP
	NOP
	NOP
	NOP
	BTFSS STATUS,C
	RETURN
	GOTO X002
; Adcin Routine
A001:	RLF R0L,F
	RLF R0L,F
	RLF R0L,F
	MOVLW 0x38
	ANDWF R0L,F
	MOVLW 0xC1
	IORWF R0L,W
	MOVWF ADCON0
	MOVLW 0x14
	MOVWF R4L
	CALL X001
	BSF ADCON0,GO
A002:	BTFSC ADCON0,GO
	GOTO A002
	BCF PIR1,ADIF
	BCF ADCON0,ADON
	RETURN
; I2CWrite Routine
IC01:	MOVWF R0L
	MOVLW 0x08
	MOVWF R0H
IC02:	RLF R0L,F
	BTFSC STATUS,C
	CALL IC20
	BTFSS STATUS,C
	CALL IC21
	CALL IC22
	CALL IC23
	DECFSZ R0H,F
	GOTO IC02
	CALL IC24
	CALL IC03
	CALL IC25
	CALL IC21
	RETURN
IC03:	CALL IC22
	MOVF SDA_PORT,W
	MOVWF FSR
	MOVF SDA_BIT,W
	ANDWF INDF,W
	ADDLW 0xFF
	CALL IC23
	RETURN
IC31:	CALL IC21
	CALL IC23
	GOTO IC29
IC41:	CALL IC22
	CALL IC20
	GOTO IC29
IC20:	MOVF SDA_PORT,W
	MOVWF FSR
	MOVF SDA_BIT,W
	IORWF INDF,F
	GOTO IC28
IC21:	MOVF SDA_PORT,W
	MOVWF FSR
	COMF SDA_BIT,W
	ANDWF INDF,F
	GOTO IC28
IC22:	MOVF SCL_PORT,W
	MOVWF FSR
	MOVF SCL_BIT,W
	IORWF INDF,F
	GOTO IC28
IC23:	MOVF SCL_PORT,W
	MOVWF FSR
	COMF SCL_BIT,W
	ANDWF INDF,F
	GOTO IC28
IC28:	BSF FSR,7
	COMF INDF,W
	BCF FSR,7
	ANDWF INDF,F
IC29:	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	RETURN
IC24:	MOVF SDA_PORT,W
	MOVWF FSR
	BSF FSR,7
	MOVF SDA_BIT,W
	IORWF INDF,F
	RETURN
IC25:	MOVF SDA_PORT,W
	MOVWF FSR
	BSF FSR,7
	COMF SDA_BIT,W
	ANDWF INDF,F
	RETURN
; I2CRead Routine
IC11:	CALL IC24
	MOVLW 0x08
	MOVWF R0H
IC12:	CALL IC03
	RLF R0L,F
	DECFSZ R0H,F
	GOTO IC12
	CALL IC25
	CALL IC20
	CALL IC22
	CALL IC23
	CALL IC21
	MOVF R0L,W
	RETURN
IC13:	CALL IC24
	MOVLW 0x08
	MOVWF R0H
IC14:	CALL IC03
	RLF R0L,F
	DECFSZ R0H,F
	GOTO IC14
	CALL IC25
	CALL IC21
	CALL IC22
	CALL IC23
	MOVF R0L,W
	RETURN
; End of listing
	END
