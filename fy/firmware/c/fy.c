/*
 Rocrail - Model Railroad Software

 Copyright (C) Rob Versluis <r.j.versluis@rocrail.net>

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

/* ----------------------------------------------------------------------- */
/* Template source file generated by piklab */
#include <pic16f873.h>
#include "fy.h"
#include "utils.h"

/*
  command for gpsim:
  gpsim -pp16f873 -s fy.cod fy.asm
*/

/* fiddleyard controller
   After startup the display is set to 0 end the ledOK will flash 4 times.
   The FY will try to reach the microBegin before going into setup/operate mode.
*/
#define CONF_WORD 0x3f3a

/* ----------------------------------------------------------------------- */
/* Configuration bits */
unsigned int at 0x2007 CONFIG = CONF_WORD;



/* Global */
static unsigned char choice    = 0;  // wanted track position
static unsigned char curtrack  = 0;  // current track position

static unsigned int pulswidth     = 0;
static unsigned int MAX_STEPS     = 65530;
static unsigned int MAX_PULSWIDTH = 30000;
static unsigned int MIN_PULSWIDTH = 15000;
static unsigned int initpos       = 32765;
static unsigned int stepnr        = 0;


/*
 * interrupt service routine
 */
void isr() interrupt 0 {                                                                                                      /* << insert interrupt code >> */
}


/*
 * init all I/O ports
 */
void initIO(void) {
  /* portA all digital I/O */
  ADCON1 = 0x06;
  /* setting I/O function to port pins */
  TRISA = 0x08;
  TRISB = 0xF0;
  TRISC = 0xF7;
}


/*
 * show current choice on the 7 segment display
 */
void updateDisplay(void) {
  unsigned int c = choice;
  unsigned int h = c / 10;
  unsigned int l = c % 10;

  display = h;
  displayH = 1;
  waitMS(20);
  displayH = 0;

  display = l;
  displayL = 1;
  waitMS(20);
  displayL = 0;
}


/*
 * flash the ledOK as confirmation
 */
void confirm(unsigned char cnt) {
  unsigned char n;

  for( n = 0; n < cnt; n++ ) {
    ledOK = LEDOK_ON;
    waitMS(250);
    ledOK = LEDOK_OFF;
    waitMS(250);
  };
}


/*
 * one step for left or right movement
 */
void oneStep(unsigned char dir) {
  cw_ccw = dir;
  cl_puls = 0;
  waitUS( pulswidth );
  cl_puls = 1;
  waitUS( pulswidth );
}

unsigned int getPosition(unsigned char pos) {
  unsigned char hb = 0;
  unsigned char lb = 0;
  unsigned int stepnr = 0;
  unsigned char idx = (pos-1) * 2;
  hb = readByte(idx);
  lb = readByte(idx+1);
  stepnr = ((unsigned int)(lb) | ((unsigned int)((unsigned int)(hb) * 256 )));
  return stepnr;
}

void savePosition(unsigned char pos, unsigned int stepnr) {
  unsigned char hb = (unsigned char)(stepnr / 256 );
  unsigned char lb = (unsigned char)(stepnr % 256 );
  unsigned char idx = (pos-1) * 2;
  saveByte(idx, hb);
  saveByte(idx+1, lb);
}


/*
 * setup service to define the track positions
 * control remains in this function as long as the setup button is active
 */
void setup(void) {
  confirm(5);

  // start with position mid
  stepnr = initpos;
  choice = MAX_TRACKS / 2 + 1;
  updateDisplay();

  pulswidth = MAX_PULSWIDTH;
  power = POWER_ON;
  waitMS(100);

  curtrack = choice;

  while( buttonSetup == BUTTON_ON ) {
    waitMS(10);

    if( buttonRight == BUTTON_ON && buttonLeft == BUTTON_ON ) {
      saveByte( ADDR_KEEPPOWER, readByte(ADDR_KEEPPOWER) ? KEEPPOWER_OFF:KEEPPOWER_ON );
      confirm(3);
      while( buttonRight == BUTTON_ON && buttonLeft == BUTTON_ON );
    }

    while( stepnr < MAX_STEPS && buttonLeft == BUTTON_OFF && buttonRight == BUTTON_ON ) {
      // turn right; end position is not reached
      stepnr++;
      oneStep(STEP_RIGHT);
    };

    while( stepnr > 0 && buttonLeft == BUTTON_ON && buttonRight == BUTTON_OFF ) {
      // turn left; start position is not reached
      stepnr--;
      oneStep(STEP_LEFT);
    };

    // check if the buttonSave is pressed
    if( buttonSave == BUTTON_ON ) {
      // save the new position in eeprom
      savePosition( choice, stepnr);
      confirm(1);

      choice++;
      if( choice > MAX_TRACKS )
        choice = 1;
      curtrack = choice;
      updateDisplay();

      while( buttonSave == BUTTON_ON )
        waitMS(10);
    }

    // check if the buttonNext is pressed
    if( buttonNext == BUTTON_ON ) {
      confirm(1);

      choice++;
      if( choice > MAX_TRACKS )
        choice = 1;
      curtrack = choice;
      updateDisplay();

      while( buttonNext == BUTTON_ON )
        waitMS(10);
    }

  } // end while

  if( !readByte(ADDR_KEEPPOWER) )
    power = POWER_OFF;  /* power off step motor */
}


void initPositions(void) {
  waitMS(100);

  if( getPosition(choice) == 0 || getPosition(choice) == 0xFFFF ) {
    unsigned char i;

    for( i = 1; i <= MAX_TRACKS; i++ ) {
        // not initialized before
        savePosition(i, initpos);
    }
    // default power off step motor
    saveByte(ADDR_KEEPPOWER, KEEPPOWER_OFF);
  }
  // always set the calibration position
  savePosition(choice, initpos);
}



/*
 * initialize all before processing
 */
void startup(void) {
  // configure the ports
  initIO();

  waitMS(10);

  // test display
  choice = 41;
  updateDisplay();
  waitMS(1000);

  choice   = MAX_TRACKS/2 +1;
  curtrack = choice;

  initPositions();
  updateDisplay();

  // get the permanent power setting from eeprom
  if( !readByte(ADDR_KEEPPOWER) )
    power = POWER_OFF;

  // signal started up
  confirm(4);
}


/*
 * move the FY to the new track position
 */

void move(void) {
  unsigned char alive = 0;
  unsigned int diff = 0;
  unsigned int newpos = 0;

  stepnr = getPosition(curtrack);
  newpos = getPosition(choice);

  ledOK = LEDOK_OFF;

  if( stepnr == newpos ) {
    waitMS( 500 );
    ledOK = LEDOK_ON;
    return;
  }

  updateDisplay();
  power = POWER_ON;
  pulswidth = MAX_PULSWIDTH;

  while( stepnr != newpos ) {

    if( stepnr > newpos ) {
      diff = stepnr - newpos;
      stepnr--;
      oneStep(STEP_LEFT);
    }
    else if( stepnr < newpos ) {
      diff = newpos - stepnr;
      stepnr++;
      oneStep(STEP_RIGHT);
    }

    if( diff < 150 && pulswidth < MAX_PULSWIDTH ) {
      // slower
      pulswidth += (MAX_PULSWIDTH - pulswidth) / 150;
    }
    else if(pulswidth > MIN_PULSWIDTH) {
      // faster
      pulswidth -= (pulswidth - MIN_PULSWIDTH) / 150;
    }

    alive++;

    if( alive > 100 ) {
      //ledOK = !ledOK;
      alive = 0;
    }

  }; // end while


  if( !readByte(ADDR_KEEPPOWER) )
    power = POWER_OFF;

  curtrack = choice;
  ledOK = LEDOK_ON;

}


/*
 * check for manual actions
 */
void manualmode(void) {
  if( buttonRight == BUTTON_ON ) {
    choice++;
    if( choice > MAX_TRACKS )
      choice = 1;
    move();
    while( buttonRight == BUTTON_ON );
    return;
  }
  if( buttonLeft == BUTTON_ON ) {
    choice--;
    if( choice < 1 )
      choice = MAX_TRACKS;
    move();
    while( buttonLeft == BUTTON_ON );
    return;
  }
}


/*
 * get the new position from decoder
 */
void automode(void) {
  unsigned char choice1;
  unsigned char choice2;

  if( newPos != INPUT_ON ) {
    return;
  }

  do {
    waitMS(10);
    choice1 = dataIn >> 4;
    waitMS(10);
    choice2 = dataIn >> 4;
  } while( choice1 != choice2 );

  if( choice1 < MAX_TRACKS ) {
    choice = choice1;

    if( choice == 0 )
      choice = MAX_TRACKS / 2 + 1;

    waitMS(100);
    move();

  }

}


/*
 * the program start
 */
void main(void) {
  unsigned char state = STATE_STARTUP;

  /* state machine */
  while(1) { /* Loop forever */

    switch( state ) {
      case STATE_STARTUP:
        startup();
        state = STATE_INIT;
        break;

      case STATE_INIT:
        state = STATE_OPERATE;
        break;

      case STATE_SETUP:
        setup();
        state = STATE_INIT;
        break;

      case STATE_OPERATE:
        if( buttonSetup == BUTTON_ON ) {
          state = STATE_SETUP;
        }
        else {
          automode();
          manualmode();
        }
        break;

    } // end switch

  }; // end while

}
